# -*- coding: utf-8 -*-
"""crowd analysis(count + flow logic) .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zCsDP5uotBYxC2-w5VP9pHaJMp5oQKOd
"""

import cv2
import numpy as np
from ultralytics import YOLO

# -------- CONFIG --------
input_video = "/content/drive/MyDrive/Crowd_Analysis_Project/data/videos/crowd.mp4"
output_video = "/content/drive/MyDrive/Crowd_Analysis_Project/outputs/crowd_analysis_final.mp4"
grid_size = 50
min_magnitude = 0.3
# ------------------------

# Load model
model = YOLO("yolov8n.pt")

cap = cv2.VideoCapture(input_video)
fps = int(cap.get(cv2.CAP_PROP_FPS))
w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

out = cv2.VideoWriter(
    output_video,
    cv2.VideoWriter_fourcc(*"mp4v"),
    fps,
    (w, h)
)

ret, prev_frame = cap.read()
prev_gray = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2GRAY)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # ---- YOLO People Detection ----
    results = model(frame)
    boxes = []
    centers = []

    for r in results:
        for box, cls in zip(r.boxes.xyxy.cpu().numpy(),
                            r.boxes.cls.cpu().numpy()):
            if int(cls) == 0:
                x1, y1, x2, y2 = map(int, box)
                boxes.append((x1, y1, x2, y2))
                centers.append(((x1+x2)//2, (y1+y2)//2))
                cv2.rectangle(frame, (x1,y1), (x2,y2), (0,255,0), 2)

    # ---- Optical Flow ----
    flow = cv2.calcOpticalFlowFarneback(
        prev_gray, gray,
        None, 0.5, 3, 15, 3, 5, 1.2, 0
    )

    mask = np.zeros((h, w), dtype=np.uint8)
    for (x1,y1,x2,y2) in boxes:
        mask[y1:y2, x1:x2] = 1

    flow_x = flow[...,0] * mask
    flow_y = flow[...,1] * mask

    # ---- Region-wise Flow ----
    for y in range(0, h, grid_size):
        for x in range(0, w, grid_size):
            fx = flow_x[y:y+grid_size, x:x+grid_size]
            fy = flow_y[y:y+grid_size, x:x+grid_size]
            if fx.size == 0:
                continue

            avg_fx = np.mean(fx)
            avg_fy = np.mean(fy)
            mag = np.sqrt(avg_fx**2 + avg_fy**2)

            if mag > min_magnitude:
                cx = x + grid_size//2
                cy = y + grid_size//2
                cv2.arrowedLine(
                    frame,
                    (cx, cy),
                    (int(cx+avg_fx*3), int(cy+avg_fy*3)),
                    (0,0,255),
                    2,
                    tipLength=0.4
                )

    # ---- Count ----
    cv2.putText(
        frame,
        f"People Count: {len(centers)}",
        (20,40),
        cv2.FONT_HERSHEY_SIMPLEX,
        1,
        (255,255,255),
        2
    )

    out.write(frame)
    prev_gray = gray.copy()

cap.release()
out.release()

print("âœ… FINAL VIDEO SAVED:", output_video)